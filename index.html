<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Choice Test</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #eaeaea;
            padding-bottom: 20px;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .description {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        .question-container {
            margin-bottom: 30px;
            border: 1px solid #eaeaea;
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .question-container:hover {
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
        }

        .question-text {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option {
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
        }

        .option:hover {
            background-color: #f8f9fa;
        }

        .option input {
            margin-right: 10px;
        }

        .option.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .option.incorrect {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .result-container {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            background-color: #f8f9fa;
            display: none;
        }

        .result-container.show {
            display: block;
        }

        .score {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .score-text {
            font-size: 1.1rem;
            color: #495057;
        }

        .restart-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 15px;
            transition: background-color 0.3s;
        }

        .restart-btn:hover {
            background-color: #2980b9;
        }

        .progress-bar {
            height: 6px;
            background-color: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
        }

        .progress {
            height: 100%;
            background-color: #3498db;
            width: 0%;
            transition: width 0.5s ease;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            padding-left: 20px;
            /* Add space for the progress bar */
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }

            .question-container {
                padding: 15px;
            }

            body {
                padding-bottom: 26px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Multiple Choice Test</h1>
            <p class="description">Select the correct answer for each question. You'll get immediate feedback.</p>
            <div style="margin-top: 15px;">
                <label for="subject-select">Select Subject: </label>
                <select id="subject-select">
                    <option value="">-- Select a Subject --</option>
                </select>
                <label for="exam-select">Select Exam: </label>
                <select id="exam-select" disabled>
                    <option value="">-- Select an Exam --</option>
                </select>
                <button id="load-exam-btn" style="margin-left: 10px;">Load Exam</button>
            </div>
        </header>

        <div id="test-container">
            <!-- Questions will be inserted here by JavaScript -->
        </div>

        <div class="result-container" id="result-container">
            <div class="score" id="score">Score: 0/0</div>
            <p class="score-text" id="score-text">Complete the test to see your score!</p>
            <button class="restart-btn" id="restart-btn">Restart Test</button>
        </div>
    </div>

    <div class="progress-bar">
        <div class="progress" id="progress"></div>
    </div>

    <script>
        // DOM elements
        const testContainer = document.getElementById('test-container');
        const resultContainer = document.getElementById('result-container');
        const scoreElement = document.getElementById('score');
        const scoreTextElement = document.getElementById('score-text');
        const restartBtn = document.getElementById('restart-btn');
        const progressBar = document.getElementById('progress');
        const subjectSelect = document.getElementById('subject-select');
        const examSelect = document.getElementById('exam-select');
        const loadExamBtn = document.getElementById('load-exam-btn');

        // Global variables to store original and randomized questions
        let questions = []; // Original questions from JSON
        let randomizedQuestions = []; // Randomized questions for display
        let userAnswers = [];
        let score = 0;

        // Function to shuffle choices and update the correct answer index accordingly
        function randomizeQuestion(question) {
            // Create an array of objects that includes both the choice text and the original index
            const choicesWithIndices = question.choices.map((choice, index) => ({
                text: choice,
                originalIndex: index
            }));

            // Fisher-Yates shuffle algorithm
            for (let i = choicesWithIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [choicesWithIndices[i], choicesWithIndices[j]] = [choicesWithIndices[j], choicesWithIndices[i]];
            }

            // Extract the shuffled choices and create a mapping from new index to original index
            const shuffledChoices = choicesWithIndices.map(item => item.text);
            const newToOriginalIndexMap = choicesWithIndices.map(item => item.originalIndex);

            // Find the new index of the correct answer based on the shuffle
            const newCorrectIndex = newToOriginalIndexMap.indexOf(question.correct);

            // Return the question with shuffled choices and updated correct answer index
            return {
                question: question.question,
                choices: shuffledChoices,
                correct: newCorrectIndex,
                originalCorrectIndex: question.correct // Keep original for reference if needed
            };
        }

        // Available subjects and exams - will be loaded dynamically from the server or cache
        let availableSubjects = [];
        let cachedExamData = null;

        // Fetch available exam files from the server and cache their content
        async function loadAvailableExams() {
            // First, try to load from cache
            cachedExamData = loadFromCache();

            if (cachedExamData) {
                // Use cached data if available and valid
                availableSubjects = cachedExamData.availableSubjects;
                populateSubjectDropdown();
                return;
            }

            // If no valid cache, fetch from server
            try {
                // Try the absolute path first, then fallback to relative path if behind a proxy
                let response;
                try {
                    response = await fetch('/api/exams');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                } catch (error) {
                    // If absolute path fails, try relative path (for proxy scenarios)
                    response = await fetch('./api/exams');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                }

                const subjectsData = await response.json();

                // Convert the API response to the format expected by the UI
                availableSubjects = subjectsData.map(subject => {
                    const exams = subject.exams.map(exam => {
                        return {
                            value: `json/${subject.name}/${exam.name}`, // Add path prefix for loading
                            label: exam.name.replace(/\.jsonc?$/, '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()), // Format filename as label (removes both .json and .jsonc from end)
                            content: exam.content // Store the content directly from the API response
                        };
                    });
                    return {
                        name: subject.name,
                        exams: exams
                    };
                });

                // Add the root directory examQuestions.json if it exists
                try {
                    const rootExamResponse = await fetch('examQuestions.json');
                    if (rootExamResponse.ok) {
                        // Fetch the content of examQuestions.json to include in cache
                        const rootExamContent = await rootExamResponse.json();
                        // Add it to a default subject if it exists, or create a default subject
                        let defaultSubject = availableSubjects.find(subject => subject.name === 'General');
                        if (!defaultSubject) {
                            defaultSubject = {
                                name: 'General',
                                exams: []
                            };
                            availableSubjects.unshift(defaultSubject);
                        }
                        defaultSubject.exams.unshift({
                            value: 'examQuestions.json',
                            label: 'Robotics Sensors Exam',
                            content: rootExamContent
                        });
                    }
                } catch (error) {
                    console.log('No root examQuestions.json found, continuing with json directory exams only');
                }

                // Now we have all the content, save it to cache
                const cacheData = {
                    availableSubjects: availableSubjects
                };
                saveToCache(cacheData);

                populateSubjectDropdown();
            } catch (error) {
                console.error('Error loading available exams:', error);

                // Try to use cache as fallback if API fails
                cachedExamData = loadFromCache();
                if (cachedExamData) {
                    availableSubjects = cachedExamData.availableSubjects;
                    populateSubjectDropdown();
                    return;
                }

                // If no cache, use a minimal default
                availableSubjects = [{ name: 'General', exams: [{ value: 'examQuestions.json', label: 'Robotics Sensors Exam', content: [] }] }];
                populateSubjectDropdown();
            }
        }

        // Populate the subject selection dropdown
        function populateSubjectDropdown() {
            subjectSelect.innerHTML = '<option value="">-- Select a Subject --</option>';
            availableSubjects.forEach(subject => {
                const option = document.createElement('option');
                option.value = subject.name;
                option.textContent = subject.name;
                subjectSelect.appendChild(option);
            });
        }

        // Populate the exam selection dropdown based on selected subject
        function populateExamDropdownBySubject(subjectName) {
            examSelect.innerHTML = '<option value="">-- Select an Exam --</option>';
            examSelect.disabled = false;

            if (!subjectName) {
                examSelect.disabled = true;
                return;
            }

            const subject = availableSubjects.find(s => s.name === subjectName);
            if (subject && subject.exams) {
                subject.exams.forEach(exam => {
                    const option = document.createElement('option');
                    option.value = exam.value;
                    option.textContent = exam.label;
                    examSelect.appendChild(option);
                });
            }
        }

        // Fetch questions from the server based on selected exam or use cached data
        async function loadQuestions(examFile) {
            try {
                // First, check if we have the exam in our cached data
                let cachedExam = null;
                for (const subject of availableSubjects) {
                    for (const exam of subject.exams) {
                        if (exam.value === examFile) {
                            cachedExam = exam;
                            break;
                        }
                    }
                    if (cachedExam) break;
                }

                if (cachedExam && cachedExam.content) {
                    // Use cached content if available
                    questions = cachedExam.content;
                    userAnswers = Array(questions.length).fill(null);
                    initializeTest();
                    return;
                }

                // If not in cache, fetch from server
                const response = await fetch(examFile);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                questions = await response.json();
                userAnswers = Array(questions.length).fill(null);
                initializeTest();
            } catch (error) {
                console.error('Error loading questions:', error);

                // Try to use cached exam as fallback
                let cachedExam = null;
                for (const subject of availableSubjects) {
                    for (const exam of subject.exams) {
                        if (exam.value === examFile) {
                            cachedExam = exam;
                            break;
                        }
                    }
                    if (cachedExam) break;
                }

                if (cachedExam && cachedExam.content) {
                    console.log('Using cached exam data as fallback');
                    questions = cachedExam.content;
                    userAnswers = Array(questions.length).fill(null);
                    initializeTest();
                    return;
                }

                testContainer.innerHTML = '<p style="color: red;">Failed to load questions. Please try again later.</p>';
            }
        }

        // Cache management functions
        const CACHE_KEY = 'examDataCache';

        // Function to save exam data to localStorage
        function saveToCache(examData) {
            try {
                const cacheData = {
                    timestamp: Date.now(),
                    examData: examData
                };
                localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
                console.log('Exam data saved to cache');
            } catch (error) {
                console.error('Failed to save to cache:', error);
            }
        }

        // Function to load exam data from localStorage
        function loadFromCache() {
            try {
                const cachedData = localStorage.getItem(CACHE_KEY);
                if (cachedData) {
                    const parsedData = JSON.parse(cachedData);
                    // Check if cache is still valid (less than 24 hours old)
                    const cacheAge = Date.now() - parsedData.timestamp;
                    const maxCacheAge = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                    if (cacheAge < maxCacheAge) {
                        console.log('Loaded exam data from cache');
                        return parsedData.examData;
                    } else {
                        console.log('Cache expired, will fetch fresh data');
                        return null;
                    }
                }
            } catch (error) {
                console.error('Failed to load from cache:', error);
            }
            return null;
        }

        // Function to clear the cache
        function clearCache() {
            localStorage.removeItem(CACHE_KEY);
        }

        // Function to refresh the cache by fetching fresh data from the server
        async function refreshCache() {
            try {
                // Try the absolute path first, then fallback to relative path if behind a proxy
                let response;
                try {
                    response = await fetch('/api/exams');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                } catch (error) {
                    // If absolute path fails, try relative path (for proxy scenarios)
                    response = await fetch('./api/exams');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                }

                const subjectsData = await response.json();

                // Convert the API response to the format expected by the UI
                const refreshedAvailableSubjects = subjectsData.map(subject => {
                    const exams = subject.exams.map(exam => {
                        return {
                            value: `json/${subject.name}/${exam.name}`, // Add path prefix for loading
                            label: exam.name.replace(/\.jsonc?$/, '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()), // Format filename as label (removes both .json and .jsonc from end)
                            content: exam.content // Store the content directly from the API response
                        };
                    });
                    return {
                        name: subject.name,
                        exams: exams
                    };
                });

                // Add the root directory examQuestions.json if it exists
                try {
                    const rootExamResponse = await fetch('examQuestions.json');
                    if (rootExamResponse.ok) {
                        // Fetch the content of examQuestions.json to include in cache
                        const rootExamContent = await rootExamResponse.json();
                        // Add it to a default subject if it exists, or create a default subject
                        let defaultSubject = refreshedAvailableSubjects.find(subject => subject.name === 'General');
                        if (!defaultSubject) {
                            defaultSubject = {
                                name: 'General',
                                exams: []
                            };
                            refreshedAvailableSubjects.unshift(defaultSubject);
                        }
                        defaultSubject.exams.unshift({
                            value: 'examQuestions.json',
                            label: 'Robotics Sensors Exam',
                            content: rootExamContent
                        });
                    }
                } catch (error) {
                    console.log('No root examQuestions.json found, continuing with json directory exams only');
                }

                // Save the refreshed data to cache
                const cacheData = {
                    availableSubjects: refreshedAvailableSubjects
                };
                saveToCache(cacheData);

                // Update the availableSubjects variable
                availableSubjects = refreshedAvailableSubjects;

                console.log('Cache refreshed successfully');
                return true;
            } catch (error) {
                console.error('Error refreshing cache:', error);
                return false;
            }
        }

        // Function to convert newline characters to HTML <br> tags
        function convertNewlinesToHTML(text) {
            return text.replace(/\n/g, '<br>');
        }

        // Function to shuffle an array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const newArray = [...array]; // Create a copy to avoid mutating the original
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Initialize the test
        function initializeTest() {
            testContainer.innerHTML = '';

            // First, shuffle the order of questions
            const shuffledQuestions = shuffleArray(questions);
            // Then, randomize choices within each question
            randomizedQuestions = shuffledQuestions.map(question => randomizeQuestion(question));
            userAnswers = Array(randomizedQuestions.length).fill(null);
            score = 0;
            resultContainer.classList.remove('show');

            // Create question elements with randomized choices
            randomizedQuestions.forEach((questionData, index) => {
                const questionElement = document.createElement('div');
                questionElement.className = 'question-container';
                questionElement.id = `question-${index}`;
                // Format question and choices to handle newlines
                const formattedQuestion = convertNewlinesToHTML(questionData.question);
                const formattedChoicesHTML = questionData.choices.map((choice, choiceIndex) =>
                    '<label class="option">' +
                    '<input type="radio" name="question-' + index + '" value="' + choiceIndex + '">' +
                    convertNewlinesToHTML(choice) +
                    '</label>'
                ).join('');

                // Build complete HTML string with formatted content
                const questionHTML = '<div class="question-text">' + (index + 1) + '. ' + formattedQuestion + '</div>' +
                    '<div class="options-container" id="options-' + index + '">' +
                    formattedChoicesHTML +
                    '</div>';

                questionElement.innerHTML = questionHTML;

                testContainer.appendChild(questionElement);

                // Add event listeners to options
                const options = questionElement.querySelectorAll('input[type="radio"]');
                options.forEach(option => {
                    option.addEventListener('change', () => {
                        handleAnswer(index, parseInt(option.value));
                    });
                });
            });

            updateProgress();
        }

        // Handle user's answer
        function handleAnswer(questionIndex, selectedChoice) {
            userAnswers[questionIndex] = selectedChoice;

            // Get the correct answer from the randomized questions
            const correctAnswer = randomizedQuestions[questionIndex].correct;

            // Get all options for this question
            const optionsContainer = document.getElementById(`options-${questionIndex}`);
            const options = optionsContainer.querySelectorAll('.option');
            const radioButtons = optionsContainer.querySelectorAll('input[type="radio"]');

            // Reset all options to default state
            options.forEach(option => {
                option.classList.remove('correct', 'incorrect');
            });

            // Highlight the selected option
            if (selectedChoice === correctAnswer) {
                options[selectedChoice].classList.add('correct');
            } else {
                options[selectedChoice].classList.add('incorrect');
                // Also show the correct answer
                options[correctAnswer].classList.add('correct');
            }

            // Disable all radio buttons for this question after selection
            radioButtons.forEach(radio => {
                radio.disabled = true;
            });

            // Update score
            updateScore();
            updateProgress();

            // Check if all questions are answered
            if (userAnswers.every(answer => answer !== null)) {
                showResults();
            }
        }

        // Update the score
        function updateScore() {
            score = userAnswers.reduce((total, answer, index) => {
                return total + (answer === randomizedQuestions[index].correct ? 1 : 0);
            }, 0);
        }

        // Update progress bar
        function updateProgress() {
            const answeredCount = userAnswers.filter(answer => answer !== null).length;
            const progressPercentage = (answeredCount / questions.length) * 100;
            progressBar.style.width = `${progressPercentage}%`;
        }


        // Show final results
        function showResults() {
            scoreElement.textContent = `Score: ${score}/${randomizedQuestions.length}`;

            // Set score message based on performance
            const percentage = (score / randomizedQuestions.length) * 100;
            let message = '';
            if (percentage >= 90) {
                message = 'Excellent work!';
            } else if (percentage >= 70) {
                message = 'Good job!';
            } else if (percentage >= 50) {
                message = 'Not bad!';
            } else {
                message = 'Keep practicing!';
            }

            scoreTextElement.textContent = message;
            resultContainer.classList.add('show');
        }

        // Event listener for restart button
        restartBtn.addEventListener('click', () => {
            initializeTest();
            // Scroll back to the top when restart button is clicked
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Event listener for subject selection
        subjectSelect.addEventListener('change', function() {
            const selectedSubject = this.value;
            populateExamDropdownBySubject(selectedSubject);
        });

        // Event listener for load exam button
        loadExamBtn.addEventListener('click', () => {
            const selectedExam = examSelect.value;
            if (!selectedExam) {
                alert('Please select both a subject and an exam first.');
                return;
            }
            loadQuestions(selectedExam);
        });

        // Initialize the dropdown when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Clear the cache to ensure fresh data is loaded
            clearCache();
            loadAvailableExams();
        });
    </script>
</body>

</html>