<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Choice Test</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #eaeaea;
            padding-bottom: 20px;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .description {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        .question-container {
            margin-bottom: 30px;
            border: 1px solid #eaeaea;
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .question-container:hover {
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
        }

        .question-text {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .options-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option {
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
        }

        .option:hover {
            background-color: #f8f9fa;
        }

        .option input {
            margin-right: 10px;
        }

        .option.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .option.incorrect {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .result-container {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            background-color: #f8f9fa;
            display: none;
        }

        .result-container.show {
            display: block;
        }

        .score {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .score-text {
            font-size: 1.1rem;
            color: #495057;
        }

        .restart-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 15px;
            transition: background-color 0.3s;
        }

        .restart-btn:hover {
            background-color: #2980b9;
        }

        .progress-bar {
            height: 6px;
            background-color: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
        }

        .progress {
            height: 100%;
            background-color: #3498db;
            width: 0%;
            transition: width 0.5s ease;
        }

        .vertical-progress-container {
            position: fixed;
            left: 0;
            top: 0;
            width: 20px;
            height: 100vh;
            background-color: #f0f0f0;
            z-index: 999;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 60px;
            /* This is default, but can be overridden by JavaScript */
        }

        .vertical-progress-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin: 5px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .vertical-progress-indicator.answered {
            background-color: #2ecc71;
        }

        .vertical-progress-indicator.missed {
            background-color: #e74c3c;
        }

        .vertical-progress-indicator.unanswered {
            background-color: #bdc3c7;
        }

        .vertical-progress-indicator:hover {
            transform: scale(1.2);
        }

        .scroll-indicator {
            position: absolute;
            left: 0;
            width: 100%;
            background-color: rgba(52, 152, 219, 0.5);
            z-index: 1;
            transition: top 0.1s ease;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            padding-left: 40px;
            /* Add space for the vertical progress bar */
            padding-bottom: 26px;
            /* Add space for the progress bar */
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }

            .question-container {
                padding: 15px;
            }

            body {
                padding-bottom: 26px;
            }
        }
    </style>
</head>

<body>
    <div class="vertical-progress-container" id="vertical-progress-container">
        <div class="scroll-indicator" id="scroll-indicator"></div>
    </div>
    <div class="container">
        <header>
            <h1>Multiple Choice Test</h1>
            <p class="description">Select the correct answer for each question. You'll get immediate feedback.</p>
            <div style="margin-top: 15px;">
                <label for="subject-select">Select Subject: </label>
                <select id="subject-select">
                    <option value="">-- Select a Subject --</option>
                </select>
                <label for="exam-select">Select Exam: </label>
                <select id="exam-select" disabled>
                    <option value="">-- Select an Exam --</option>
                </select>
                <button id="load-exam-btn" style="margin-left: 10px;">Load Exam</button>
            </div>
        </header>

        <div id="test-container">
            <!-- Questions will be inserted here by JavaScript -->
        </div>

        <div class="result-container" id="result-container">
            <div class="score" id="score">Score: 0/0</div>
            <p class="score-text" id="score-text">Complete the test to see your score!</p>
            <button class="restart-btn" id="restart-btn">Restart Test</button>
        </div>
    </div>

    <div class="progress-bar">
        <div class="progress" id="progress"></div>
    </div>

    <script>
        // DOM elements
        const testContainer = document.getElementById('test-container');
        const resultContainer = document.getElementById('result-container');
        const scoreElement = document.getElementById('score');
        const scoreTextElement = document.getElementById('score-text');
        const restartBtn = document.getElementById('restart-btn');
        const progressBar = document.getElementById('progress');
        const subjectSelect = document.getElementById('subject-select');
        const examSelect = document.getElementById('exam-select');
        const loadExamBtn = document.getElementById('load-exam-btn');
        const verticalProgressContainer = document.getElementById('vertical-progress-container');
        const scrollIndicator = document.getElementById('scroll-indicator');

        // Global variables to store original and randomized questions
        let questions = []; // Original questions from JSON
        let randomizedQuestions = []; // Randomized questions for display
        let userAnswers = [];
        let score = 0;

        // Global variables for vertical progress bar adjustments
        const VERTICAL_PROGRESS_OFFSET = 15; // Pixels of offset from top (adjustable)
        const VERTICAL_SCROLL_INDICATOR_MIN_HEIGHT = 2; // Minimum height of the scroll indicator in percent (adjustable)

        // Function to shuffle choices and update the correct answer index accordingly
        function randomizeQuestion(question) {
            // Create an array of objects that includes both the choice text and the original index
            const choicesWithIndices = question.choices.map((choice, index) => ({
                text: choice,
                originalIndex: index
            }));

            // Fisher-Yates shuffle algorithm
            for (let i = choicesWithIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [choicesWithIndices[i], choicesWithIndices[j]] = [choicesWithIndices[j], choicesWithIndices[i]];
            }

            // Extract the shuffled choices and create a mapping from new index to original index
            const shuffledChoices = choicesWithIndices.map(item => item.text);
            const newToOriginalIndexMap = choicesWithIndices.map(item => item.originalIndex);

            // Find the new index of the correct answer based on the shuffle
            const newCorrectIndex = newToOriginalIndexMap.indexOf(question.correct);

            // Return the question with shuffled choices and updated correct answer index
            return {
                question: question.question,
                choices: shuffledChoices,
                correct: newCorrectIndex,
                originalCorrectIndex: question.correct // Keep original for reference if needed
            };
        }

        // Available subjects and exams - will be loaded dynamically from the server or cache
        let availableSubjects = [];
        let cachedExamData = null;

        // Fetch available exam files from the server and cache their content
        async function loadAvailableExams() {
            // First, try to load from cache
            cachedExamData = loadFromCache();

            if (cachedExamData) {
                // Use cached data if available and valid
                availableSubjects = cachedExamData.availableSubjects;
                populateSubjectDropdown();
                return;
            }

            // If no valid cache, fetch from server
            try {
                const response = await fetch('/api/exams');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const subjectsData = await response.json();

                // Convert the API response to the format expected by the UI
                availableSubjects = subjectsData.map(subject => {
                    const exams = subject.exams.map(exam => {
                        return {
                            value: `json/${subject.name}/${exam.name}`, // Add path prefix for loading
                            label: exam.name.replace(/\.jsonc?$/, '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()), // Format filename as label (removes both .json and .jsonc from end)
                            content: exam.content // Store the content directly from the API response
                        };
                    });
                    return {
                        name: subject.name,
                        exams: exams
                    };
                });

                // Add the root directory examQuestions.json if it exists
                try {
                    const rootExamResponse = await fetch('examQuestions.json');
                    if (rootExamResponse.ok) {
                        // Fetch the content of examQuestions.json to include in cache
                        const rootExamContent = await rootExamResponse.json();
                        // Add it to a default subject if it exists, or create a default subject
                        let defaultSubject = availableSubjects.find(subject => subject.name === 'General');
                        if (!defaultSubject) {
                            defaultSubject = {
                                name: 'General',
                                exams: []
                            };
                            availableSubjects.unshift(defaultSubject);
                        }
                        defaultSubject.exams.unshift({
                            value: 'examQuestions.json',
                            label: 'Robotics Sensors Exam',
                            content: rootExamContent
                        });
                    }
                } catch (error) {
                    console.log('No root examQuestions.json found, continuing with json directory exams only');
                }

                // Now we have all the content, save it to cache
                const cacheData = {
                    availableSubjects: availableSubjects
                };
                saveToCache(cacheData);

                populateSubjectDropdown();
            } catch (error) {
                console.error('Error loading available exams:', error);

                // Try to use cache as fallback if API fails
                cachedExamData = loadFromCache();
                if (cachedExamData) {
                    availableSubjects = cachedExamData.availableSubjects;
                    populateSubjectDropdown();
                    return;
                }

                // If no cache, use a minimal default
                availableSubjects = [{ name: 'General', exams: [{ value: 'examQuestions.json', label: 'Robotics Sensors Exam', content: [] }] }];
                populateSubjectDropdown();
            }
        }

        // Populate the subject selection dropdown
        function populateSubjectDropdown() {
            subjectSelect.innerHTML = '<option value="">-- Select a Subject --</option>';
            availableSubjects.forEach(subject => {
                const option = document.createElement('option');
                option.value = subject.name;
                option.textContent = subject.name;
                subjectSelect.appendChild(option);
            });
        }

        // Populate the exam selection dropdown based on selected subject
        function populateExamDropdownBySubject(subjectName) {
            examSelect.innerHTML = '<option value="">-- Select an Exam --</option>';
            examSelect.disabled = false;

            if (!subjectName) {
                examSelect.disabled = true;
                return;
            }

            const subject = availableSubjects.find(s => s.name === subjectName);
            if (subject && subject.exams) {
                subject.exams.forEach(exam => {
                    const option = document.createElement('option');
                    option.value = exam.value;
                    option.textContent = exam.label;
                    examSelect.appendChild(option);
                });
            }
        }

        // Fetch questions from the server based on selected exam or use cached data
        async function loadQuestions(examFile) {
            try {
                // First, check if we have the exam in our cached data
                let cachedExam = null;
                for (const subject of availableSubjects) {
                    for (const exam of subject.exams) {
                        if (exam.value === examFile) {
                            cachedExam = exam;
                            break;
                        }
                    }
                    if (cachedExam) break;
                }

                if (cachedExam && cachedExam.content) {
                    // Use cached content if available
                    questions = cachedExam.content;
                    userAnswers = Array(questions.length).fill(null);
                    initializeTest();
                    return;
                }

                // If not in cache, fetch from server
                const response = await fetch(examFile);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                questions = await response.json();
                userAnswers = Array(questions.length).fill(null);
                initializeTest();
            } catch (error) {
                console.error('Error loading questions:', error);

                // Try to use cached exam as fallback
                let cachedExam = null;
                for (const subject of availableSubjects) {
                    for (const exam of subject.exams) {
                        if (exam.value === examFile) {
                            cachedExam = exam;
                            break;
                        }
                    }
                    if (cachedExam) break;
                }

                if (cachedExam && cachedExam.content) {
                    console.log('Using cached exam data as fallback');
                    questions = cachedExam.content;
                    userAnswers = Array(questions.length).fill(null);
                    initializeTest();
                    return;
                }

                testContainer.innerHTML = '<p style="color: red;">Failed to load questions. Please try again later.</p>';
            }
        }

        // Cache management functions
        const CACHE_KEY = 'examDataCache';

        // Function to save exam data to localStorage
        function saveToCache(examData) {
            try {
                const cacheData = {
                    timestamp: Date.now(),
                    examData: examData
                };
                localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
                console.log('Exam data saved to cache');
            } catch (error) {
                console.error('Failed to save to cache:', error);
            }
        }

        // Function to load exam data from localStorage
        function loadFromCache() {
            try {
                const cachedData = localStorage.getItem(CACHE_KEY);
                if (cachedData) {
                    const parsedData = JSON.parse(cachedData);
                    // Check if cache is still valid (less than 24 hours old)
                    const cacheAge = Date.now() - parsedData.timestamp;
                    const maxCacheAge = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                    if (cacheAge < maxCacheAge) {
                        console.log('Loaded exam data from cache');
                        return parsedData.examData;
                    } else {
                        console.log('Cache expired, will fetch fresh data');
                        return null;
                    }
                }
            } catch (error) {
                console.error('Failed to load from cache:', error);
            }
            return null;
        }

        // Function to clear the cache
        function clearCache() {
            localStorage.removeItem(CACHE_KEY);
        }

        // Function to refresh the cache by fetching fresh data from the server
        async function refreshCache() {
            try {
                const response = await fetch('/api/exams');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const subjectsData = await response.json();

                // Convert the API response to the format expected by the UI
                const refreshedAvailableSubjects = subjectsData.map(subject => {
                    const exams = subject.exams.map(exam => {
                        return {
                            value: `json/${subject.name}/${exam.name}`, // Add path prefix for loading
                            label: exam.name.replace(/\.jsonc?$/, '').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()), // Format filename as label (removes both .json and .jsonc from end)
                            content: exam.content // Store the content directly from the API response
                        };
                    });
                    return {
                        name: subject.name,
                        exams: exams
                    };
                });

                // Add the root directory examQuestions.json if it exists
                try {
                    const rootExamResponse = await fetch('examQuestions.json');
                    if (rootExamResponse.ok) {
                        // Fetch the content of examQuestions.json to include in cache
                        const rootExamContent = await rootExamResponse.json();
                        // Add it to a default subject if it exists, or create a default subject
                        let defaultSubject = refreshedAvailableSubjects.find(subject => subject.name === 'General');
                        if (!defaultSubject) {
                            defaultSubject = {
                                name: 'General',
                                exams: []
                            };
                            refreshedAvailableSubjects.unshift(defaultSubject);
                        }
                        defaultSubject.exams.unshift({
                            value: 'examQuestions.json',
                            label: 'Robotics Sensors Exam',
                            content: rootExamContent
                        });
                    }
                } catch (error) {
                    console.log('No root examQuestions.json found, continuing with json directory exams only');
                }

                // Save the refreshed data to cache
                const cacheData = {
                    availableSubjects: refreshedAvailableSubjects
                };
                saveToCache(cacheData);

                // Update the availableSubjects variable
                availableSubjects = refreshedAvailableSubjects;

                console.log('Cache refreshed successfully');
                return true;
            } catch (error) {
                console.error('Error refreshing cache:', error);
                return false;
            }
        }

        // Function to shuffle an array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const newArray = [...array]; // Create a copy to avoid mutating the original
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Initialize the test
        function initializeTest() {
            testContainer.innerHTML = '';
            // Clear only the question indicators, keep the scroll indicator
            const existingScrollIndicator = document.querySelector('.scroll-indicator');
            verticalProgressContainer.innerHTML = ''; // Clear everything first
            if (existingScrollIndicator) {
                // Add the scroll indicator back to the container
                verticalProgressContainer.appendChild(existingScrollIndicator);
            } else {
                // If for some reason it doesn't exist, create it
                const newScrollIndicator = document.createElement('div');
                newScrollIndicator.className = 'scroll-indicator';
                newScrollIndicator.id = 'scroll-indicator';
                verticalProgressContainer.appendChild(newScrollIndicator);
            }

            // First, shuffle the order of questions
            const shuffledQuestions = shuffleArray(questions);
            // Then, randomize choices within each question
            randomizedQuestions = shuffledQuestions.map(question => randomizeQuestion(question));
            userAnswers = Array(randomizedQuestions.length).fill(null);
            score = 0;
            resultContainer.classList.remove('show');

            // Create question elements with randomized choices
            randomizedQuestions.forEach((questionData, index) => {
                const questionElement = document.createElement('div');
                questionElement.className = 'question-container';
                questionElement.id = `question-${index}`; // Add ID for linking to vertical progress indicators
                questionElement.innerHTML = `
                    <div class="question-text">${index + 1}. ${questionData.question}</div>
                    <div class="options-container" id="options-${index}">
                        ${questionData.choices.map((choice, choiceIndex) => `
                            <label class="option">
                                <input type="radio" name="question-${index}" value="${choiceIndex}">
                                ${choice}
                            </label>
                        `).join('')}
                    </div>
                `;

                testContainer.appendChild(questionElement);

                // Add event listeners to options
                const options = questionElement.querySelectorAll('input[type="radio"]');
                options.forEach(option => {
                    option.addEventListener('change', () => {
                        handleAnswer(index, parseInt(option.value));
                    });
                });

                // Create vertical progress indicator for this question
                const indicator = document.createElement('div');
                indicator.className = 'vertical-progress-indicator unanswered';
                indicator.dataset.questionIndex = index;
                indicator.title = `Question ${index + 1}`;

                // Add click event to scroll to question
                indicator.addEventListener('click', () => {
                    const questionElement = document.getElementById(`question-${index}`);
                    if (questionElement) {
                        questionElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                });

                verticalProgressContainer.appendChild(indicator);
            });

            updateProgress();
        }

        // Handle user's answer
        function handleAnswer(questionIndex, selectedChoice) {
            userAnswers[questionIndex] = selectedChoice;

            // Get the correct answer from the randomized questions
            const correctAnswer = randomizedQuestions[questionIndex].correct;

            // Get all options for this question
            const optionsContainer = document.getElementById(`options-${questionIndex}`);
            const options = optionsContainer.querySelectorAll('.option');
            const radioButtons = optionsContainer.querySelectorAll('input[type="radio"]');

            // Reset all options to default state
            options.forEach(option => {
                option.classList.remove('correct', 'incorrect');
            });

            // Highlight the selected option
            if (selectedChoice === correctAnswer) {
                options[selectedChoice].classList.add('correct');
            } else {
                options[selectedChoice].classList.add('incorrect');
                // Also show the correct answer
                options[correctAnswer].classList.add('correct');
            }

            // Disable all radio buttons for this question after selection
            radioButtons.forEach(radio => {
                radio.disabled = true;
            });

            // Update vertical progress indicator
            const indicator = document.querySelector(`.vertical-progress-indicator[data-question-index="${questionIndex}"]`);
            if (indicator) {
                // Remove all classes
                indicator.classList.remove('answered', 'missed', 'unanswered');

                // Add appropriate class based on answer correctness
                if (selectedChoice === correctAnswer) {
                    indicator.classList.add('answered');
                } else {
                    indicator.classList.add('missed');
                }
            }

            // Update score
            updateScore();
            updateProgress();

            // Check if all questions are answered
            if (userAnswers.every(answer => answer !== null)) {
                showResults();
            }
        }

        // Update the score
        function updateScore() {
            score = userAnswers.reduce((total, answer, index) => {
                return total + (answer === randomizedQuestions[index].correct ? 1 : 0);
            }, 0);
        }

        // Update progress bar
        function updateProgress() {
            const answeredCount = userAnswers.filter(answer => answer !== null).length;
            const progressPercentage = (answeredCount / questions.length) * 100;
            progressBar.style.width = `${progressPercentage}%`;

            // Update vertical progress indicators
            document.querySelectorAll('.vertical-progress-indicator').forEach((indicator, index) => {
                if (userAnswers[index] === null) {
                    if (!indicator.classList.contains('answered') && !indicator.classList.contains('missed')) {
                        indicator.classList.add('unanswered');
                    }
                }
            });
        }

        // Function to update the scroll indicator position
        function updateScrollIndicator() {
            const currentScrollIndicator = document.querySelector('#vertical-progress-container .scroll-indicator');
            if (currentScrollIndicator) {
                // Calculate the offset of the test container from the top
                const testContainerElement = document.getElementById('test-container');
                if (!testContainerElement) return;

                const containerRect = testContainerElement.getBoundingClientRect();
                const containerTop = containerRect.top + window.scrollY;
                const containerHeight = testContainerElement.scrollHeight;

                // Calculate viewport and document dimensions
                const viewportHeight = window.innerHeight;
                const documentHeight = document.body.scrollHeight;

                // Calculate how much of the document is remaining to scroll after the container
                const contentBelowContainer = documentHeight - (containerTop + containerHeight);
                const scrollableArea = documentHeight - viewportHeight;

                // Calculate the range where scrolling affects the container position
                const scrollRange = containerHeight + contentBelowContainer;

                // Determine where in the scroll range we are
                if (window.scrollY <= containerTop) {
                    // Before the container
                    currentScrollIndicator.style.top = `${(containerTop / documentHeight) * 100}%`;
                } else if (window.scrollY >= containerTop + containerHeight - viewportHeight) {
                    // After we've scrolled through the container
                    currentScrollIndicator.style.top = `${((containerTop + containerHeight - viewportHeight) / documentHeight) * 100}%`;
                } else {
                    // Somewhere within the container scroll range
                    const relativeScrollPosition = window.scrollY - containerTop;
                    const percentageOfContainerScroll = relativeScrollPosition / (containerHeight - viewportHeight);
                    const maxScrollIndicatorTop = ((containerTop + containerHeight - viewportHeight) / documentHeight) * 100;
                    const minScrollIndicatorTop = (containerTop / documentHeight) * 100;

                    currentScrollIndicator.style.top = `${minScrollIndicatorTop + (maxScrollIndicatorTop - minScrollIndicatorTop) * percentageOfContainerScroll}%`;
                }

                // Calculate the height of the scroll indicator based on viewport size
                currentScrollIndicator.style.height = `${Math.max(VERTICAL_SCROLL_INDICATOR_MIN_HEIGHT, (viewportHeight / documentHeight) * 100)}%`;
            }
        }

        // Throttle function to limit how often a function can run
        function throttle(func, limit) {
            let inThrottle;
            return function () {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        // Add scroll event listener with throttling to improve performance
        window.addEventListener('scroll', throttle(updateScrollIndicator, 100));

        // Show final results
        function showResults() {
            scoreElement.textContent = `Score: ${score}/${randomizedQuestions.length}`;

            // Set score message based on performance
            const percentage = (score / randomizedQuestions.length) * 100;
            let message = '';
            if (percentage >= 90) {
                message = 'Excellent work!';
            } else if (percentage >= 70) {
                message = 'Good job!';
            } else if (percentage >= 50) {
                message = 'Not bad!';
            } else {
                message = 'Keep practicing!';
            }

            scoreTextElement.textContent = message;
            resultContainer.classList.add('show');
        }

        // Event listener for restart button
        restartBtn.addEventListener('click', () => {
            initializeTest();
            // Scroll back to the top when restart button is clicked
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Event listener for subject selection
        subjectSelect.addEventListener('change', function() {
            const selectedSubject = this.value;
            populateExamDropdownBySubject(selectedSubject);
        });

        // Event listener for load exam button
        loadExamBtn.addEventListener('click', () => {
            const selectedExam = examSelect.value;
            if (!selectedExam) {
                alert('Please select both a subject and an exam first.');
                return;
            }
            loadQuestions(selectedExam);
        });

        // Initialize the dropdown when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Clear the cache to ensure fresh data is loaded
            clearCache();
            loadAvailableExams();
            // Initialize scroll indicator position
            updateScrollIndicator();
            // Apply the offset to the vertical progress container
            if (verticalProgressContainer) {
                verticalProgressContainer.style.paddingTop = `${VERTICAL_PROGRESS_OFFSET}px`;
            }
        });

        // Update scroll indicator on window resize
        window.addEventListener('resize', updateScrollIndicator);
    </script>
</body>

</html>